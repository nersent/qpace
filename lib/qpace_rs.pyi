# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import datetime
import typing
from enum import Enum, auto

class ArcOhlcv:
    r"""
    Multi-threaded immutable OHLCV data.
    """
    bars: builtins.list[OhlcvBar]
    def __new__(cls,bars:typing.Optional[typing.Sequence[OhlcvBar]]=None): ...
    def bars_from_slice(self, slice:slice) -> builtins.list[OhlcvBar]:
        ...

    def bar(self, index:builtins.int) -> OhlcvBar:
        ...

    def __len__(self) -> builtins.int:
        ...

    def __format__(self, format_spec:typing.Optional[builtins.str]=None) -> builtins.str:
        ...

    @staticmethod
    def read_path(path:builtins.str) -> ArcOhlcv:
        ...

    @staticmethod
    def from_bars(bars:typing.Sequence[OhlcvBar]) -> ArcOhlcv:
        ...

    @staticmethod
    def from_pandas(df:typing.Any) -> ArcOhlcv:
        ...


class Backtest:
    config: BacktestConfig
    ctx: Ctx
    equity: builtins.float
    net_equity: builtins.float
    equity_series: builtins.list[builtins.float]
    net_equity_series: builtins.list[builtins.float]
    equity_returns: builtins.list[builtins.float]
    net_equity_returns: builtins.list[builtins.float]
    pnl_series: builtins.list[builtins.float]
    open_profit: builtins.float
    net_profit: builtins.float
    gross_profit: builtins.float
    gross_loss: builtins.float
    winning_trades: builtins.int
    losing_trades: builtins.int
    position_size: builtins.float
    open_trades: builtins.list[Trade]
    closed_trades: builtins.list[Trade]
    trades: builtins.list[Trade]
    open_longs: builtins.int
    open_shorts: builtins.int
    closed_longs: builtins.int
    closed_shorts: builtins.int
    total_longs: builtins.int
    total_shorts: builtins.int
    total_trades: builtins.int
    instrument_price: builtins.float
    win_rate: builtins.float
    profit_factor: builtins.float
    def __new__(cls,py_ctx:Ctx, config:BacktestConfig): ...
    def on_bar_open(self) -> None:
        ...

    def on_bar_close(self) -> None:
        ...

    def signal(self, signal:Signal) -> None:
        ...

    def signal_batch(self, signals:typing.Sequence[typing.Optional[Signal]]) -> None:
        r"""
        Processes multiple signals at once. `signals` must be aligned with all bars. `signals: [bar_index_0_signal, bar_index_1_signal, ...]`.
        """
        ...

    def signal_batch_dict(self, signals:typing.Mapping[builtins.int, Signal]) -> None:
        r"""
        Processes multiple signals at once. `signals: [bar_index, Signal]`.
        """
        ...

    def skip_remaining_bars(self) -> None:
        ...

    def skip_to_bar(self, bar_index:builtins.int) -> None:
        ...

    def skip_bars(self, bars:builtins.int) -> None:
        ...

    def to_pine(self) -> builtins.str:
        ...

    def __len__(self) -> builtins.int:
        ...

    def summary(self) -> typing.Any:
        ...

    def __next__(self) -> builtins.int:
        ...

    def __iter__(self) -> Backtest:
        ...


class BacktestConfig:
    initial_capital: builtins.float
    process_orders_on_close: builtins.bool
    def __new__(cls,initial_capital:builtins.float=1000.0, process_orders_on_close:builtins.bool=False): ...

class Ctx:
    bar_index: builtins.int
    bar: OhlcvBar
    is_initialized: builtins.bool
    sym_info: SymInfo
    ohlcv: typing.Optional[Ohlcv]
    arc_ohlcv: typing.Optional[ArcOhlcv]
    @staticmethod
    def from_arc_ohlcv(ohlcv:ArcOhlcv, sym_info:typing.Optional[SymInfo]=None) -> Ctx:
        ...

    @staticmethod
    def from_ohlcv(ohlcv:Ohlcv, sym_info:typing.Optional[SymInfo]=None) -> Ctx:
        ...

    def fork(self) -> Ctx:
        ...

    def next(self) -> typing.Optional[builtins.int]:
        r"""
        Creates a fresh instance that can be run again. Reuses same OHLCV and symbol.
        """
        ...

    def __len__(self) -> builtins.int:
        ...

    def __next__(self) -> builtins.int:
        ...

    def __iter__(self) -> Ctx:
        ...


class Ohlcv:
    r"""
    Single-threaded mutable OHLCV data.
    """
    bars: builtins.list[OhlcvBar]
    def __new__(cls,bars:typing.Optional[typing.Sequence[OhlcvBar]]=None): ...
    def bars_from_slice(self, slice:slice) -> builtins.list[OhlcvBar]:
        ...

    def bar(self, index:builtins.int) -> OhlcvBar:
        ...

    def __len__(self) -> builtins.int:
        ...

    def __format__(self, format_spec:typing.Optional[builtins.str]=None) -> builtins.str:
        ...

    def push(self, bar:OhlcvBar) -> None:
        ...

    def push_many(self, bars:typing.Sequence[OhlcvBar]) -> None:
        ...

    @staticmethod
    def read_path(path:builtins.str) -> Ohlcv:
        ...

    @staticmethod
    def from_bars(bars:typing.Sequence[OhlcvBar]) -> Ohlcv:
        ...

    @staticmethod
    def from_pandas(df:typing.Any) -> Ohlcv:
        ...


class OhlcvBar:
    open_time: datetime.datetime
    close_time: datetime.datetime
    open: builtins.float
    high: builtins.float
    low: builtins.float
    close: builtins.float
    volume: builtins.float
    hl2: builtins.float
    hlc3: builtins.float
    hlcc4: builtins.float
    def __new__(cls,open_time:typing.Optional[datetime.datetime]=None, close_time:typing.Optional[datetime.datetime]=None, open:typing.Optional[builtins.float]=None, high:typing.Optional[builtins.float]=None, low:typing.Optional[builtins.float]=None, close:typing.Optional[builtins.float]=None, volume:typing.Optional[builtins.float]=None): ...
    def __format__(self, format_spec:typing.Optional[builtins.str]=None) -> builtins.str:
        ...


class Order:
    ...

class OrderBook:
    ...

class OrderConfig:
    ...

class Signal:
    kind: SignalKind
    id: typing.Optional[builtins.str]
    def py_set_id(self, id:typing.Optional[builtins.str]) -> None:
        ...

    @staticmethod
    def hold() -> Signal:
        ...

    @staticmethod
    def size(size:builtins.float) -> Signal:
        ...

    @staticmethod
    def equity_pct(equity_pct:builtins.float) -> Signal:
        ...

    @staticmethod
    def close_all() -> Signal:
        ...

    @staticmethod
    def long() -> Signal:
        ...

    @staticmethod
    def short() -> Signal:
        ...


class SymInfo:
    min_tick: builtins.float
    min_qty: builtins.float
    timeframe: Timeframe
    @staticmethod
    def btc_usd() -> SymInfo:
        ...

    @staticmethod
    def eth_usd() -> SymInfo:
        ...

    @staticmethod
    def sol_usd() -> SymInfo:
        ...


class Trade:
    size: builtins.float
    entry: typing.Optional[TradeEvent]
    exit: typing.Optional[TradeEvent]
    pnl: builtins.float
    direction: TradeDirection
    is_active: builtins.bool
    is_closed: builtins.bool
    def to_dict(self) -> typing.Any:
        ...


class TradeEvent:
    id: typing.Optional[builtins.str]
    order_bar_index: builtins.int
    fill_bar_index: builtins.int
    price: builtins.float
    comment: typing.Optional[builtins.str]
    def to_dict(self) -> typing.Any:
        ...


class SignalKind(Enum):
    Size = auto()
    EquityPct = auto()
    Hold = auto()
    CloseAll = auto()

class Timeframe(Enum):
    Years = auto()
    Months = auto()
    Weeks = auto()
    Days = auto()
    Hours = auto()
    Minutes = auto()
    Seconds = auto()
    Ticks = auto()
    Ranges = auto()
    Unknown = auto()

class TradeDirection(Enum):
    Long = auto()
    Short = auto()

def get_version() -> builtins.str:
    ...

