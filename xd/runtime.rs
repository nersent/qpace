/*
This file was generated by qPACE compiler. DO NOT EDIT!

https://qpace.dev

https://github.com/nersent/qpace

Date: 2025-03-08T12:51:31.121Z
*/

use std::ops::{AddAssign, SubAssign};
use core::f64;
use std::{cell::RefCell, rc::Rc};
use std::marker::PhantomData;
use pyo3::prelude::*;
use std::cell::{Ref, RefMut};
use qpace_core::ctx::Ctx;
use qpace_core::backtest::Backtest;
use pyo3::exceptions::PyTypeError;

pub struct PineCtx {
    pub ctx: Rc<RefCell<Ctx>>,
    pub bt: Option<Rc<RefCell<Backtest>>>,
}

impl PineCtx {
    #[inline]
    pub fn new(ctx: Rc<RefCell<Ctx>>) -> PineCtx {
        return PineCtx {
            ctx,
            bt: None,
        };
    }

    #[inline]
    pub fn new_bt(ctx: Rc<RefCell<Ctx>>, bt: Backtest) -> PineCtx {
        return PineCtx {
            ctx,
            bt: Some(Rc::new(RefCell::new(bt))),
        };
    }
}

pub trait Default {
    fn default() -> Self;
}

pub trait Na {
    fn na(self) -> bool;
}

impl Default for f64 {
    fn default() -> f64 {
        return f64::NAN;
    }
}

impl Default for bool {
    fn default() -> bool {
        return false;
    }
}



#[derive(Debug, Clone, Copy)]
pub struct PineFloat(pub f64);

impl Na for &PineFloat {
    #[inline]
    fn na(self) -> bool {
        return self.0.is_nan();
    }
}

impl Na for PineFloat {
    #[inline]
    fn na(self) -> bool {
        return (&self).na();
    }
}

impl std::ops::Add for PineFloat {
    type Output = PineFloat;

    #[inline]
    fn add(self, other: PineFloat) -> PineFloat {
        return PineFloat(self.0 + other.0);
    }
}

impl std::ops::Sub for PineFloat {
    type Output = PineFloat;

    #[inline]
    fn sub(self, other: PineFloat) -> PineFloat {
        return PineFloat(self.0 - other.0);
    }
}

impl std::ops::Mul for PineFloat {
    type Output = PineFloat;

    #[inline]
    fn mul(self, other: PineFloat) -> PineFloat {
        return PineFloat(self.0 * other.0);
    }
}

impl std::ops::Div for PineFloat {
    type Output = PineFloat;

    #[inline]
    fn div(self, other: PineFloat) -> PineFloat {
        if other.0 == 0.0 {
            return PineFloat(f64::NAN);
        }
        return PineFloat(self.0 / other.0);
    }
}

impl std::ops::Neg for PineFloat {
    type Output = PineFloat;

    #[inline]
    fn neg(self) -> PineFloat {
        return PineFloat(-self.0);
    }
}

impl std::cmp::PartialEq for PineFloat {
    #[inline]
    fn eq(&self, other: &PineFloat) -> bool {
        return self.0 == other.0;
    }
}

impl std::cmp::PartialOrd for PineFloat {
    #[inline]
    fn partial_cmp(&self, other: &PineFloat) -> Option<std::cmp::Ordering> {
        return self.0.partial_cmp(&other.0);
    }
}

impl std::convert::From<f64> for PineFloat {
    #[inline]
    fn from(x: f64) -> PineFloat {
        return PineFloat(x);
    }
}

impl std::convert::From<PineFloat> for f64 {
    #[inline]
    fn from(x: PineFloat) -> f64 {
        return x.0;
    }
}

impl std::convert::From<Option<usize>> for PineFloat {
    #[inline]
    fn from(x: Option<usize>) -> PineFloat {
        return PineFloat(x.map(|x| x as f64).unwrap_or(f64::NAN));
    }
}

impl Default for PineFloat {
    #[inline]
    fn default() -> PineFloat {
        return PineFloat(f64::NAN);
    }
}

impl IntoPy<PyObject> for PineFloat {
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        return self.0.into_py(py);
    }
}

impl FromPyObject<'_> for PineFloat {
    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
        if let Ok(val) = ob.extract::<f64>() {
            return Ok(PineFloat(val));
        }
        if ob.is_none() {
            return Ok(PineFloat(f64::NAN));
        }
        return Err(PyErr::new::<PyTypeError, _>("Invalid type, expected float"));
    }
}
    

#[derive(Debug, Clone, Copy)]
pub struct PineInt(pub Option<i64>);

impl Na for &PineInt {
    #[inline]
    fn na(self) -> bool {
        return self.0.is_none();
    }
}

impl Na for PineInt {
    #[inline]
    fn na(self) -> bool {
        return (&self).na();
    }
}

impl std::cmp::PartialEq for PineInt {
    #[inline]
    fn eq(&self, other: &PineInt) -> bool {
        return self.0 == other.0;
    }
}

impl std::cmp::PartialOrd for PineInt {
    #[inline]
    fn partial_cmp(&self, other: &PineInt) -> Option<std::cmp::Ordering> {
        return self.0.partial_cmp(&other.0);
    }
}


impl std::ops::Add for PineInt {
    type Output = PineInt;

    #[inline]
    fn add(self, other: PineInt) -> PineInt {
        if self.0.is_none() || other.0.is_none() {
            return PineInt(None);
        }
        return PineInt(Some(self.0.unwrap() + other.0.unwrap()));
    }
}

impl std::ops::Sub for PineInt {
    type Output = PineInt;

    #[inline]
    fn sub(self, other: PineInt) -> PineInt {
        if self.0.is_none() || other.0.is_none() {
            return PineInt(None);
        }
        return PineInt(Some(self.0.unwrap() - other.0.unwrap()));
    }
}

impl std::ops::Mul for PineInt {
    type Output = PineInt;

    #[inline]
    fn mul(self, other: PineInt) -> PineInt {
        if self.0.is_none() || other.0.is_none() {
            return PineInt(None);
        }
        return PineInt(Some(self.0.unwrap() * other.0.unwrap()));
    }
}

impl std::ops::Div for PineInt {
    type Output = PineInt;

    #[inline]
    fn div(self, other: PineInt) -> PineInt {
        if self.0.is_none() || other.0.is_none() || other.0.unwrap() == 0 {
            return PineInt(None);
        }
        return PineInt(Some(self.0.unwrap() / other.0.unwrap()));
    }
}

impl std::ops::Neg for PineInt {
    type Output = PineInt;

    #[inline]
    fn neg(self) -> PineInt {
        return PineInt(self.0.map(|x| -x));
    }
}

impl std::convert::From<Option<i64>> for PineInt {
    #[inline]
    fn from(x: Option<i64>) -> PineInt {
        return PineInt(x);
    }
}

impl std::convert::From<i64> for PineInt {
    #[inline]
    fn from(x: i64) -> PineInt {
        return PineInt(Some(x));
    }
}

impl std::convert::From<PineInt> for usize {
    #[inline]
    fn from(x: PineInt) -> usize {
        return x.0.unwrap_or(0) as usize;
    }
}

impl std::convert::From<Option<usize>> for PineInt {
    #[inline]
    fn from(x: Option<usize>) -> PineInt {
        return PineInt(x.map(|x| x as i64));
    }
}

impl std::convert::From<Option<i32>> for PineInt {
    #[inline]
    fn from(x: Option<i32>) -> PineInt {
        return PineInt(x.map(|x| x as i64));
    }
}

impl std::convert::From<i32> for PineInt {
    #[inline]
    fn from(x: i32) -> PineInt {
        return PineInt(Some(x as i64));
    }
}

impl std::convert::From<Option<u8>> for PineInt {
    #[inline]
    fn from(x: Option<u8>) -> PineInt {
        return PineInt(x.map(|x| x as i64));
    }
}

impl std::convert::From<u8> for PineInt {
    #[inline]
    fn from(x: u8) -> PineInt {
        return PineInt(Some(x as i64));
    }
}

impl std::convert::From<PineInt> for u8 {
    #[inline]
    fn from(x: PineInt) -> u8 {
        return x.0.unwrap_or(0) as u8;
    }
}

impl std::convert::From<f64> for PineInt {
    #[inline]
    fn from(x: f64) -> PineInt {
        return PineInt(Some(x as i64));
    }
}

impl Default for PineInt {
    #[inline]
    fn default() -> PineInt {
        return PineInt(None);
    }
}

impl IntoPy<PyObject> for PineInt {
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        return self.0.into_py(py);
    }
}

impl FromPyObject<'_> for PineInt {
    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
        if let Ok(val) = ob.extract::<i64>() {
            return Ok(PineInt(Some(val)));
        }
        if ob.is_none() {
            return Ok(PineInt(None));
        }
        return Err(PyErr::new::<PyTypeError, _>("Invalid type, expected int"));
    }
}

impl std::convert::Into<Option<i64>> for PineInt {
    #[inline]
    fn into(self) -> Option<i64> {
        return self.0;
    }
}
    

#[derive(Debug, Clone, Copy)]
pub struct PineBool(pub Option<bool>);

impl Na for &PineBool {
    #[inline]
    fn na(self) -> bool {
        return self.0.is_none();
    }
}

impl Na for PineBool {
    #[inline]
    fn na(self) -> bool {
        return (&self).na();
    }
}

impl std::cmp::PartialEq for PineBool {
    #[inline]
    fn eq(&self, other: &PineBool) -> bool {
        return self.0 == other.0;
    }
}

impl std::cmp::PartialOrd for PineBool {
    #[inline]
    fn partial_cmp(&self, other: &PineBool) -> Option<std::cmp::Ordering> {
        return self.0.partial_cmp(&other.0);
    }
}


impl std::ops::BitAnd for PineBool {
    type Output = bool;

    #[inline]
    fn bitand(self, other: PineBool) -> bool {
        if self.0.is_none() || other.0.is_none() {
            return false;
        }
        return self.0.unwrap() && other.0.unwrap();
    }
}

impl std::ops::BitOr for PineBool {
    type Output = bool;

    #[inline]
    fn bitor(self, other: PineBool) -> bool {
        if self.0.is_none() || other.0.is_none() {
            return false;
        }
        return self.0.unwrap() || other.0.unwrap();
    }
}

impl std::convert::From<Option<bool>> for PineBool {
    #[inline]
    fn from(x: Option<bool>) -> PineBool {
        return PineBool(x);
    }
}

impl std::convert::From<PineBool> for bool {
    #[inline]
    fn from(x: PineBool) -> bool {
        return x.0.unwrap_or(false);
    }
}

impl std::convert::From<bool> for PineBool {
    #[inline]
    fn from(x: bool) -> PineBool {
        return PineBool(Some(x));
    }
}

impl std::ops::Not for PineBool {
    type Output = bool;

    #[inline]
    fn not(self) -> bool {
        return self.0.map(|x| !x).unwrap_or(false);
    }
}

impl Default for PineBool {
    #[inline]
    fn default() -> PineBool {
        return PineBool(None);
    }
}

impl std::convert::Into<Option<bool>> for PineBool {
    #[inline]
    fn into(self) -> Option<bool> {
        return self.0;
    }
}

impl IntoPy<PyObject> for PineBool {
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        return self.0.into_py(py);
    }
}

impl FromPyObject<'_> for PineBool {
    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
        if let Ok(val) = ob.extract::<bool>() {
            return Ok(PineBool(Some(val)));
        }
        if ob.is_none() {
            return Ok(PineBool(None));
        }
        return Err(PyErr::new::<PyTypeError, _>("Invalid type, expected bool"));
    }
}
    

#[derive(Debug, Clone)]
pub struct PineString(pub Option<String>);

impl Na for &PineString {
    #[inline]
    fn na(self) -> bool {
        return self.0.is_none();
    }
}

impl Na for PineString {
    #[inline]
    fn na(self) -> bool {
        return (&self).na();
    }
}

impl std::cmp::PartialEq for PineString {
    #[inline]
    fn eq(&self, other: &PineString) -> bool {
        return self.0 == other.0;
    }
}

impl std::cmp::PartialOrd for PineString {
    #[inline]
    fn partial_cmp(&self, other: &PineString) -> Option<std::cmp::Ordering> {
        return self.0.partial_cmp(&other.0);
    }
}


impl std::convert::From<&str> for PineString {
    #[inline]
    fn from(x: &str) -> PineString {
        return PineString(Some(x.to_string()));
    }
}

impl std::convert::From<Option<String>> for PineString {
    #[inline]
    fn from(x: Option<String>) -> PineString {
        return PineString(x);
    }
}

impl Default for PineString {
    #[inline]
    fn default() -> PineString {
        return PineString(None);
    }
}

impl IntoPy<PyObject> for PineString {
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        return self.0.into_py(py);
    }
}

impl FromPyObject<'_> for PineString {
    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
        if let Ok(val) = ob.extract::<String>() {
            return Ok(PineString(Some(val)));
        }
        if ob.is_none() {
            return Ok(PineString(None));
        }
        return Err(PyErr::new::<PyTypeError, _>("Invalid type, expected string"));
    }
}
    

#[derive(Debug, Clone, Copy)]
pub struct PineNa;

impl Na for &PineNa {
    #[inline]
    fn na(self) -> bool {
        return true;
    }
}

impl Default for PineNa {
    #[inline]
    fn default() -> PineNa {
        return PineNa;
    }
}

impl IntoPy<PyObject> for PineNa {
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        return py.None();
    }
}

impl FromPyObject<'_> for PineNa {
    fn extract_bound(ob: &Bound<'_, PyAny>) -> PyResult<Self> {
        if ob.is_none() {
            return Ok(PineNa);
        }
        return Err(PyErr::new::<PyTypeError, _>("Invalid type, expected None"));
    }
}
    

#[derive(Debug, Clone)]
pub struct PineObject<T> {
    inner: Rc<RefCell<T>>,
}

impl<T> PineObject<T> {
    #[inline]
    pub fn get(&self) -> Ref<T> {
        return self.inner.borrow();
    }

    #[inline]
    pub fn get_mut(&self) -> RefMut<T> {
        return self.inner.borrow_mut();
    }
}

impl<T> std::convert::From<T> for PineObject<T> {
    #[inline]
    fn from(inner: T) -> PineObject<T> {
        return PineObject {
            inner: Rc::new(RefCell::new(inner)),
        };
    }
}
    

#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct PineColor {
    pub r: u8,
    pub g: u8,
    pub b: u8,  
    pub a: u8,
}

impl PineColor {
    pub fn rgb(r: u8, g: u8, b: u8) -> PineColor {
        return PineColor { r, g, b, a: 255 };
    }

    pub fn rgba(r: u8, g: u8, b: u8, a: u8) -> PineColor {
        return PineColor { r, g, b, a };
    }
}

impl std::convert::From<(u8, u8, u8, u8)> for PineColor {
    #[inline]
    fn from(x: (u8, u8, u8, u8)) -> PineColor {
        return PineColor { r: x.0, g: x.1, b: x.2, a: x.3 };
    }
}

    

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct PinePlot {
}
      

#[derive(Debug, Clone, PartialEq, PartialOrd)]
pub struct PineHline {
}
        

#[derive(Debug, Clone)]
pub enum PineAny {
    PineNa,
    PineFloat(PineFloat),
    PineInt(PineInt),
    PineString(PineString),
    PineBool(PineBool),
    PineColor(PineColor),
}

impl std::ops::Add for PineAny {
    type Output = PineAny;

    #[inline]
    fn add(self, other: PineAny) -> PineAny {
        match (&self, &other) {
            (PineAny::PineFloat(a), PineAny::PineFloat(b)) => PineAny::PineFloat(*a + *b),
            (PineAny::PineInt(a), PineAny::PineInt(b)) => PineAny::PineInt(*a + *b),
            // implicit
            (PineAny::PineInt(a), PineAny::PineFloat(b)) => {
                PineFloat::from(*a + (*b).into()).into()
            },
            (PineAny::PineFloat(a), PineAny::PineInt(b)) => {
                PineFloat::from(*a + (*b).into()).into()
            },
            _ => panic!("Invalid \"+\" op {:?} {:?}", self, other),
        }
    }
}

impl std::ops::Sub for PineAny {
    type Output = PineAny;

    #[inline]
    fn sub(self, other: PineAny) -> PineAny {
        match (&self, &other) {
            (PineAny::PineFloat(a), PineAny::PineFloat(b)) => PineAny::PineFloat(*a - *b),
            (PineAny::PineInt(a), PineAny::PineInt(b)) => PineAny::PineInt(*a - *b),
            // implicit
            (PineAny::PineInt(a), PineAny::PineFloat(b)) => {
                PineFloat::from(*a - (*b).into()).into()
            },
            (PineAny::PineFloat(a), PineAny::PineInt(b)) => {
                PineFloat::from(*a - (*b).into()).into()
            },
            _ => panic!("Invalid \"-\" op {:?} {:?}", self, other),
        }
    }
}

impl std::ops::Mul for PineAny {
    type Output = PineAny;

    #[inline]
    fn mul(self, other: PineAny) -> PineAny {
        match (&self, &other) {
            (PineAny::PineFloat(a), PineAny::PineFloat(b)) => (*a * *b).into(),
            (PineAny::PineInt(a), PineAny::PineInt(b)) => (*a * *b).into(),
            // implicit
            (PineAny::PineInt(a), PineAny::PineFloat(b)) => {
                PineFloat::from(*a * (*b).into()).into()
            }
            (PineAny::PineFloat(a), PineAny::PineInt(b)) => {
                PineFloat::from(*a * (*b).into()).into()
            }
            _ => panic!("Invalid \"*\" op {:?} {:?}", self, other),
        }
    }
}

impl std::ops::Div for PineAny {
    type Output = PineAny;

    #[inline]
    fn div(self, other: PineAny) -> PineAny {
        match (&self, &other) {
            (PineAny::PineFloat(a), PineAny::PineFloat(b)) => (*a / *b).into(),
            (PineAny::PineInt(a), PineAny::PineInt(b)) => (*a / *b).into(),
            // implicit
            (PineAny::PineInt(a), PineAny::PineFloat(b)) => {
                PineFloat::from(*a / (*b).into()).into()
            },
            (PineAny::PineFloat(a), PineAny::PineInt(b)) => {
                PineFloat::from(*a / (*b).into()).into()
            },
            _ => panic!("Invalid \"/\" op {:?} {:?}", self, other),
        }
    }
}

impl std::ops::Neg for PineAny {
    type Output = PineAny;

    #[inline]
    fn neg(self) -> PineAny {
        match &self {
            PineAny::PineFloat(a) => (-*a).into(),
            PineAny::PineInt(a) => (-*a).into(),
            _ => panic!("Invalid \"-\" op {:?}", self),
        }
    }
}

impl std::ops::Not for PineAny {
    type Output = PineAny;

    #[inline]
    fn not(self) -> PineAny {
        match &self {
            PineAny::PineBool(a) => PineBool::from(!*a).into(),
            _ => panic!("Invalid \"not\" op {:?}", self),
        }
    }
}

impl std::cmp::PartialEq for PineAny {
    #[inline]
    fn eq(&self, other: &PineAny) -> bool {
        match (self, other) {
            (PineAny::PineFloat(a), PineAny::PineFloat(b)) => a == b,
            (PineAny::PineInt(a), PineAny::PineInt(b)) => a == b,
            (PineAny::PineString(a), PineAny::PineString(b)) => a == b,
            (PineAny::PineBool(a), PineAny::PineBool(b)) => a == b,
            (PineAny::PineColor(a), PineAny::PineColor(b)) => a == b,
            // implicit
            (PineAny::PineInt(a), PineAny::PineFloat(b)) => PineFloat::from(*a) == *b,
            (PineAny::PineFloat(a), PineAny::PineInt(b)) => *a == PineFloat::from(*b),
            (PineAny::PineInt(a), PineAny::PineNa) => a.na(),
            (PineAny::PineNa, PineAny::PineInt(b)) => b.na(),
            (PineAny::PineFloat(a), PineAny::PineNa) => a.na(),
            (PineAny::PineNa, PineAny::PineFloat(b)) => b.na(),
            (PineAny::PineString(a), PineAny::PineNa) => a.na(),
            (PineAny::PineNa, PineAny::PineString(b)) => b.na(),
            (PineAny::PineBool(a), PineAny::PineNa) => a.na(),
            (PineAny::PineNa, PineAny::PineBool(b)) => b.na(),
            (PineAny::PineNa, PineAny::PineNa) => true,
            _ => panic!("Invalid \"==\" op {:?} {:?}", self, other),
        }
    }
}

impl std::cmp::PartialOrd for PineAny {
    #[inline]
    fn partial_cmp(&self, other: &PineAny) -> Option<std::cmp::Ordering> {
        match (self, other) {
            (PineAny::PineFloat(a), PineAny::PineFloat(b)) => a.partial_cmp(b),
            (PineAny::PineInt(a), PineAny::PineInt(b)) => a.partial_cmp(b),
            (PineAny::PineString(a), PineAny::PineString(b)) => a.partial_cmp(b),
            (PineAny::PineBool(a), PineAny::PineBool(b)) => a.partial_cmp(b),
            (PineAny::PineColor(a), PineAny::PineColor(b)) => a.partial_cmp(b),
            // implicit
            (PineAny::PineInt(a), PineAny::PineFloat(b)) => PineFloat::from(*a).partial_cmp(b),
            (PineAny::PineFloat(a), PineAny::PineInt(b)) => a.partial_cmp(&PineFloat::from(*b)),
            (PineAny::PineInt(a), PineAny::PineNa) => Some(std::cmp::Ordering::Less),
            (PineAny::PineNa, PineAny::PineInt(b)) => Some(std::cmp::Ordering::Greater),
            (PineAny::PineFloat(a), PineAny::PineNa) => Some(std::cmp::Ordering::Less),
            (PineAny::PineNa, PineAny::PineFloat(b)) => Some(std::cmp::Ordering::Greater),
            (PineAny::PineString(a), PineAny::PineNa) => Some(std::cmp::Ordering::Less),
            (PineAny::PineNa, PineAny::PineString(b)) => Some(std::cmp::Ordering::Greater),
            (PineAny::PineBool(a), PineAny::PineNa) => Some(std::cmp::Ordering::Less),
            (PineAny::PineNa, PineAny::PineBool(b)) => Some(std::cmp::Ordering::Greater),
            (PineAny::PineNa, PineAny::PineNa) => Some(std::cmp::Ordering::Equal),
            _ => panic!("Invalid \"==\" op {:?} {:?}", self, other),
        }
    }
}

impl IntoPy<PyObject> for PineAny {
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        match self {
            PineAny::PineNa => py.None(),
            PineAny::PineFloat(val) => val.into_py(py),
            PineAny::PineInt(val) => val.into_py(py),
            PineAny::PineString(val) => val.into_py(py),
            PineAny::PineBool(val) => val.into_py(py),
            _ => panic!("Cannot convert {:?} to PyObject", self),
        }
    }
}
  

impl std::convert::From<PineFloat> for PineInt {
    #[inline]
    fn from(x: PineFloat) -> PineInt {
        return PineInt(Some(x.0 as i64));
    }
}

impl std::convert::From<PineInt> for PineFloat {
    #[inline]
    fn from(x: PineInt) -> PineFloat {
        return PineFloat(x.0.map(|x| x as f64).unwrap_or(f64::NAN));
    }
}

impl std::convert::From<PineNa> for PineInt {
    #[inline]
    fn from(_: PineNa) -> PineInt {
        return PineInt(None);
    }
}

impl std::convert::From<PineNa> for PineFloat {
    #[inline]
    fn from(_: PineNa) -> PineFloat {
        return PineFloat(f64::NAN);
    }
}

impl std::convert::From<PineNa> for PineBool {
    #[inline]
    fn from(_: PineNa) -> PineBool {
        return PineBool(None);
    }
}

impl std::convert::From<PineNa> for PineString {
    #[inline]
    fn from(_: PineNa) -> PineString {
        return PineString(None);
    }
}

impl std::convert::From<PineBool> for PineAny {
    #[inline]
    fn from(x: PineBool) -> PineAny {
        return PineAny::PineBool(x);
    }
}

impl std::convert::From<PineInt> for PineAny {
    #[inline]
    fn from(x: PineInt) -> PineAny {
        return PineAny::PineInt(x);
    }
}

impl std::convert::From<PineFloat> for PineAny {
    #[inline]
    fn from(x: PineFloat) -> PineAny {
        return PineAny::PineFloat(x);
    }
}

impl std::convert::From<PineString> for PineAny {
    #[inline]
    fn from(x: PineString) -> PineAny {
        return PineAny::PineString(x);
    }
}

impl std::convert::From<PineNa> for PineAny {
    #[inline]
    fn from(_: PineNa) -> PineAny {
        return PineAny::PineNa;
    }
}

impl std::convert::From<PineColor> for PineAny {
    #[inline]
    fn from(x: PineColor) -> PineAny {
        return PineAny::PineColor(x);
    }
}

impl std::convert::From<PineAny> for PineFloat {
    #[inline]
    fn from(x: PineAny) -> PineFloat {
        match x {
            PineAny::PineFloat(val) => val,
            PineAny::PineInt(val) => val.into(),
            _ => PineNa.into(),
        }
    }
}

impl std::convert::From<PineAny> for PineInt {
    #[inline]
    fn from(x: PineAny) -> PineInt {
        match x {
            PineAny::PineInt(val) => val,
            _ => PineNa.into(),
        }
    }
}

impl std::convert::From<PineAny> for PineBool {
    #[inline]
    fn from(x: PineAny) -> PineBool {
        match x {
            PineAny::PineBool(val) => val,
            _ => PineNa.into(),
        }
    }
}

impl std::convert::From<PineAny> for PineString {
    #[inline]
    fn from(x: PineAny) -> PineString {
        match x {
            PineAny::PineString(val) => val,
            _ => PineNa.into(),
        }
    }
}

impl std::convert::From<PineAny> for PineColor {
    #[inline]
    fn from(x: PineAny) -> PineColor {
        match x {
            PineAny::PineColor(val) => val,
            _ => panic!("Cannot convert {:?} to PineColor", x),
        }
    }
}

// impl std::convert::From<Option<(u8, u8, u8, u8)>> for Option<PineObject<PineColor>> {
//     #[inline]
//     fn from(x: Option<(u8, u8, u8, u8)>) -> Option<PineObject<PineColor>> {
//         return x.map(|(r, g, b, a)| PineColor::rgba(r, g, b, a).into());
//     }
// }

impl std::convert::From<(u8, u8, u8, u8)> for PineObject<PineColor> {
    #[inline]
    fn from(x: (u8, u8, u8, u8)) -> PineObject<PineColor> {
        return PineColor::from(x).into();
    }
}

impl std::convert::From<PineColor> for Option<PineObject<PineColor>> {
    #[inline]
    fn from(x: PineColor) -> Option<PineObject<PineColor>> {
        return Some(PineObject::from(x));
    }
}

impl std::convert::From<PineInt> for () {
    #[inline]
    fn from(_: PineInt) -> () {
        return ();
    }
}

impl std::convert::From<PineFloat> for () {
    #[inline]
    fn from(_: PineFloat) -> () {
        return ();
    }
}

impl std::convert::From<PineBool> for () {
    #[inline]
    fn from(_: PineBool) -> () {
        return ();
    }
}

impl std::convert::From<PineString> for () {
    #[inline]
    fn from(_: PineString) -> () {
        return ();
    }
}

impl<T> std::convert::From<PineObject<T>> for () {
    #[inline]
    fn from(_: PineObject<T>) -> () {
        return ();
    }
}

impl<T> std::convert::From<PineNa> for Option<PineObject<T>> {
    #[inline]
    fn from(_: PineNa) -> Option<PineObject<T>> {
        return None;
    }
}

impl<T> Na for Option<T> {
    #[inline]
    fn na(self) -> bool {
        return self.is_none();
    }
}
    

trait PineSeriesGetter<T> {
    fn get(values: &[T]) -> T;
    fn get_at(values: &[T], idx: usize) -> T;
}

impl<T: Clone + From<PineNa>> PineSeriesGetter<T> for PhantomData<T> {
    fn get(values: &[T]) -> T {
        values.last().cloned().unwrap_or_else(|| T::from(PineNa))
    }

    fn get_at(values: &[T], idx: usize) -> T {
        values.get(idx).cloned().unwrap_or_else(|| T::from(PineNa))
    }
}

impl<T: Copy + From<PineNa>> PineSeriesGetter<T> for T {
    fn get(values: &[T]) -> T {
        *values.last().unwrap_or(&T::from(PineNa))
    }

    fn get_at(values: &[T], idx: usize) -> T {
        *values.get(idx).unwrap_or(&T::from(PineNa))
    }
}

#[derive(Debug)]
pub struct PineSeries<T: Clone + From<PineNa>> {
    values: Vec<T>,
    _marker: PhantomData<T>,
}

impl<T: Clone + From<PineNa>> PineSeries<T> {
    #[inline]
    pub fn new() -> Self {
        Self {
            values: Vec::new(),
            _marker: PhantomData,
        }
    }

    #[inline]
    pub fn from(values: Vec<T>) -> Self {
        Self {
            values,
            _marker: PhantomData,
        }
    }

    #[inline]
    pub fn get(&self) -> T {
        <PhantomData<T> as PineSeriesGetter<T>>::get(&self.values)
    }

    #[inline]
    pub fn get_at(&self, idx: usize) -> T {
        <PhantomData<T> as PineSeriesGetter<T>>::get_at(&self.values, idx)
    }

    #[inline]
    pub fn get_at_offset(&self, offset: usize) -> T {
        if offset >= self.values.len() {
            return T::from(PineNa);
        }
        let idx = self.values.len() - 1 - offset;
        return self.get_at(idx);
    }

    #[inline]
    pub fn next(&mut self) {
        if self.values.len() == 0 {
            return;
        }
        self.values.push(self.get());
    }

    #[inline]
    pub fn set(&mut self, value: T) {
        self.values.pop();
        self.values.push(value);
    }
}

impl Default for PineSeries<PineFloat> {
    fn default() -> Self {
        return PineSeries::new();
    }
}

impl Default for PineSeries<PineInt> {
    fn default() -> Self {
        return PineSeries::new();
    }
}

impl Default for PineSeries<PineBool> {
    fn default() -> Self {
        return PineSeries::new();
    }
}

impl Default for PineSeries<PineString> {
    fn default() -> Self {
        return PineSeries::new();
    }
}

impl Default for PineSeries<PineAny> {
    fn default() -> Self {
        return PineSeries::new();
    }
}

impl<T> IntoPy<PyObject> for PineSeries<T>
where
    T: Clone + From<PineNa> + IntoPy<PyObject>,
{
    #[inline]
    fn into_py(self, py: Python<'_>) -> PyObject {
        self.values.into_py(py)
    }
}

impl<'py, T> FromPyObject<'py> for PineSeries<T>
where
    T: Clone + From<PineNa> + FromPyObject<'py>,
{
    fn extract_bound(ob: &Bound<'py, PyAny>) -> PyResult<Self> {
        let values = ob.extract::<Vec<T>>()?;
        Ok(PineSeries::from(values))
    }
}


pub struct OhlcvSeries {
    ctx: Rc<RefCell<Ctx>>,
    pub open: PineSeries<PineFloat>,
    pub high: PineSeries<PineFloat>,
    pub low: PineSeries<PineFloat>,
    pub close: PineSeries<PineFloat>,
    pub volume: PineSeries<PineFloat>,
    pub hl2: PineSeries<PineFloat>,
    pub hlc3: PineSeries<PineFloat>,
    pub hlcc4: PineSeries<PineFloat>,
}

impl OhlcvSeries {
    pub fn new(ctx: Rc<RefCell<Ctx>>) -> Self {
        return Self {
            ctx,
            open: PineSeries::new(),
            high: PineSeries::new(),
            low: PineSeries::new(),
            close: PineSeries::new(),
            volume: PineSeries::new(),
            hl2: PineSeries::new(),
            hlc3: PineSeries::new(),
            hlcc4: PineSeries::new(),
        };
    } 
}

impl OhlcvSeries {
    pub fn next(&mut self) {
        self.open.next();
        self.high.next();
        self.low.next();
        self.close.next();
        self.volume.next();
        self.hl2.next();
        self.hlc3.next();
        self.hlcc4.next();
        //
        let ctx = self.ctx.borrow();
        let bar = ctx.bar();
        self.open.set(bar.open().into());
        self.high.set(bar.high().into());
        self.low.set(bar.low().into());
        self.close.set(bar.close().into());
        self.volume.set(bar.volume().into());
        self.hl2.set(bar.hl2().into());
        self.hlc3.set(bar.hlc3().into());
        self.hlcc4.set(bar.hlcc4().into());
    }

    pub fn from_name(&self, name: &str) -> Option<&PineSeries<PineFloat>> {
        match name {
            "open" => Some(&self.open),
            "high" => Some(&self.high),
            "low" => Some(&self.low),
            "close" => Some(&self.close),
            "volume" => Some(&self.volume),
            "hl2" => Some(&self.hl2),
            "hlc3" => Some(&self.hlc3),
            "hlcc4" => Some(&self.hlcc4),
            _ => None,
        }
    }
}