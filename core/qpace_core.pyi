# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import datetime
import pandas
import typing
from enum import Enum, auto

class Backtest:
    initial_capital: builtins.float
    process_orders_on_close: builtins.bool
    ctx: Ctx
    equity: builtins.float
    equity_list: builtins.list[builtins.float]
    net_equity: builtins.float
    net_equity_list: builtins.list[builtins.float]
    pnl_list: builtins.list[builtins.float]
    open_profit: builtins.float
    net_profit: builtins.float
    net_profit_pct: builtins.float
    gross_profit: builtins.float
    gross_profit_pct: builtins.float
    gross_loss: builtins.float
    gross_loss_pct: builtins.float
    win_rate: builtins.float
    profit_factor: builtins.float
    avg_trade: builtins.float
    avg_winning_trade: builtins.float
    avg_losing_trade: builtins.float
    avg_win_loss_ratio: builtins.float
    returns_list: builtins.list[builtins.float]
    position_size: builtins.float
    open_trades: builtins.list[Trade]
    closed_trades: builtins.list[Trade]
    trades: builtins.list[Trade]
    def __new__(cls,ctx:Ctx, initial_capital:builtins.float=1000.0, process_orders_on_close:builtins.bool=False, debug:builtins.bool=False): ...
    def sharpe_ratio(self, rfr:builtins.float) -> builtins.float:
        ...

    def sortino_ratio(self, rfr:builtins.float) -> builtins.float:
        ...

    def on_bar_open(self) -> None:
        ...

    def on_bar_close(self) -> None:
        ...

    def signal(self, signal:Signal) -> None:
        ...

    def signal_list(self, signals:typing.Sequence[typing.Optional[Signal]]) -> None:
        ...

    def signal_dict(self, signals:typing.Mapping[builtins.int, Signal]) -> None:
        ...

    def skip(self, skip:CtxSkip) -> None:
        ...

    def __len__(self) -> builtins.int:
        ...

    def __next__(self) -> builtins.int:
        ...

    def __iter__(self) -> Backtest:
        ...

    def to_pine(self) -> builtins.str:
        ...

    def display(self) -> None:
        ...


class Ctx:
    bar_index: builtins.int
    bar: OhlcvBar
    is_initialized: builtins.bool
    sym: Sym
    ohlcv: Ohlcv
    def __new__(cls,ohlcv:typing.Optional[Ohlcv]=None, sym:typing.Optional[Sym]=None): ...
    def copy(self) -> Ctx:
        ...

    def reset(self) -> None:
        ...

    def next(self) -> typing.Optional[builtins.int]:
        ...

    def __len__(self) -> builtins.int:
        ...

    def __next__(self) -> builtins.int:
        ...

    def __iter__(self) -> Ctx:
        ...

    def skip(self, skip:CtxSkip) -> None:
        ...

    def ref(self) -> Ctx:
        ...


class CtxSkip:
    @staticmethod
    def end() -> CtxSkip:
        ...

    @staticmethod
    def bars(bars:builtins.int) -> CtxSkip:
        ...

    @staticmethod
    def bar_index(bar_index:builtins.int) -> CtxSkip:
        ...

    @staticmethod
    def open_time_eq(open_time:datetime.datetime) -> CtxSkip:
        ...

    @staticmethod
    def open_time_geq(open_time:datetime.datetime) -> CtxSkip:
        ...


class Ohlcv:
    timeframe: Timeframe
    open_time: builtins.list[typing.Optional[datetime.datetime]]
    close_time: builtins.list[typing.Optional[datetime.datetime]]
    open: builtins.list[builtins.float]
    high: builtins.list[builtins.float]
    low: builtins.list[builtins.float]
    close: builtins.list[builtins.float]
    volume: builtins.list[builtins.float]
    bars: builtins.list[OhlcvBar]
    def __new__(cls,): ...
    @staticmethod
    def from_bars(bars:typing.Sequence[OhlcvBar]) -> Ohlcv:
        ...

    def py_set_timeframe(self, timeframe:Timeframe) -> None:
        ...

    def __getitem__(self, index:builtins.int) -> typing.Optional[OhlcvBar]:
        ...

    def __len__(self) -> builtins.int:
        ...

    def slice(self, slice:slice) -> Ohlcv:
        ...

    def head(self, count:builtins.int) -> Ohlcv:
        ...

    def tail(self, count:builtins.int) -> Ohlcv:
        ...

    def copy(self) -> Ohlcv:
        ...

    def extend(self, other:Ohlcv) -> None:
        ...

    def resample(self, timeframe:Timeframe, align_utc:builtins.bool) -> Ohlcv:
        ...

    def sort(self, ascending:builtins.bool) -> None:
        ...

    def reverse(self) -> None:
        ...

    def clear(self) -> None:
        ...

    def pop(self) -> typing.Optional[OhlcvBar]:
        ...

    def shift(self) -> typing.Optional[OhlcvBar]:
        ...

    def push(self, bar:OhlcvBar) -> None:
        ...

    def push_many(self, bars:typing.Sequence[OhlcvBar]) -> None:
        ...

    @staticmethod
    def from_pandas(df:typing.Any) -> Ohlcv:
        ...

    def to_pandas(self) -> pandas.DataFrame:
        ...

    @staticmethod
    def read_csv(path:builtins.str) -> Ohlcv:
        ...

    @staticmethod
    def read_parquet(path:builtins.str) -> Ohlcv:
        ...

    def write_csv(self, path:builtins.str) -> None:
        ...

    def write_parquet(self, path:builtins.str) -> None:
        ...

    def sanity_check(self) -> tuple[builtins.bool, builtins.list[builtins.str]]:
        ...

    def ref(self) -> Ohlcv:
        ...


class OhlcvBar:
    open_time: typing.Optional[datetime.datetime]
    close_time: typing.Optional[datetime.datetime]
    open: builtins.float
    high: builtins.float
    low: builtins.float
    close: builtins.float
    volume: builtins.float
    def __new__(cls,open_time:typing.Optional[datetime.datetime]=None, close_time:typing.Optional[datetime.datetime]=None, open:typing.Optional[builtins.float]=None, high:typing.Optional[builtins.float]=None, low:typing.Optional[builtins.float]=None, close:typing.Optional[builtins.float]=None, volume:typing.Optional[builtins.float]=None): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    def py_set_open_time(self, open_time:typing.Optional[datetime.datetime]) -> None:
        ...

    def py_set_close_time(self, close_time:typing.Optional[datetime.datetime]) -> None:
        ...

    def py_set_open(self, open:builtins.float) -> None:
        ...

    def py_set_high(self, high:builtins.float) -> None:
        ...

    def py_set_low(self, low:builtins.float) -> None:
        ...

    def py_set_close(self, close:builtins.float) -> None:
        ...

    def py_set_volume(self, volume:builtins.float) -> None:
        ...

    def merge(self, other:OhlcvBar) -> OhlcvBar:
        ...

    def to_dict(self) -> typing.Any:
        ...

    @staticmethod
    def from_dict(obj:typing.Any) -> OhlcvBar:
        ...


class Signal:
    id: typing.Optional[builtins.str]
    comment: typing.Optional[builtins.str]
    @staticmethod
    def Hold() -> Signal:
        ...

    @staticmethod
    def Size(size:builtins.float) -> Signal:
        ...

    @staticmethod
    def EquityPct(equity_pct:builtins.float) -> Signal:
        ...

    @staticmethod
    def CloseAll() -> Signal:
        ...

    @staticmethod
    def Long() -> Signal:
        ...

    @staticmethod
    def Short() -> Signal:
        ...

    def py_set_id(self, id:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_comment(self, comment:typing.Optional[builtins.str]) -> None:
        ...


class Sym:
    id: typing.Optional[builtins.str]
    ticker_id: typing.Optional[builtins.str]
    kind: SymKind
    min_tick: builtins.float
    min_qty: builtins.float
    prefix: typing.Optional[builtins.str]
    currency: typing.Optional[builtins.str]
    base_currency: typing.Optional[builtins.str]
    ticker: typing.Optional[builtins.str]
    country: typing.Optional[builtins.str]
    price_scale: builtins.float
    point_value: builtins.float
    metadata: typing.Optional[builtins.str]
    def __new__(cls,): ...
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    def py_set_id(self, id:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_ticker_id(self, ticker_id:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_kind(self, kind:SymKind) -> None:
        ...

    def py_set_min_tick(self, min_tick:builtins.float) -> None:
        ...

    def py_set_min_qty(self, min_qty:builtins.float) -> None:
        ...

    def py_set_prefix(self, prefix:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_currency(self, currency:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_base_currency(self, base_currency:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_ticker(self, ticker:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_country(self, country:typing.Optional[builtins.str]) -> None:
        ...

    def py_set_price_scale(self, price_scale:builtins.float) -> None:
        ...

    def py_set_point_value(self, point_value:builtins.float) -> None:
        ...

    def py_set_metadata(self, metadata:typing.Optional[builtins.str]) -> None:
        ...

    @staticmethod
    def from_dict(dict:typing.Any) -> Sym:
        ...

    def to_dict(self) -> typing.Any:
        ...

    @staticmethod
    def BTC_USD() -> Sym:
        ...

    @staticmethod
    def ETH_USD() -> Sym:
        ...

    @staticmethod
    def SOL_USD() -> Sym:
        ...

    @staticmethod
    def DOGE_USD() -> Sym:
        ...


class SymKind:
    def __str__(self) -> builtins.str:
        ...

    def __repr__(self) -> builtins.str:
        ...

    @staticmethod
    def from_str(kind:builtins.str) -> SymKind:
        ...

    @staticmethod
    def Stock() -> SymKind:
        ...

    @staticmethod
    def Future() -> SymKind:
        ...

    @staticmethod
    def Option() -> SymKind:
        ...

    @staticmethod
    def Forex() -> SymKind:
        ...

    @staticmethod
    def Crypto() -> SymKind:
        ...

    @staticmethod
    def Unknown() -> SymKind:
        ...

    @staticmethod
    def Other(kind:builtins.str) -> SymKind:
        ...


class Timeframe:
    years: typing.Optional[builtins.int]
    months: typing.Optional[builtins.int]
    weeks: typing.Optional[builtins.int]
    days: typing.Optional[builtins.int]
    hours: typing.Optional[builtins.int]
    minutes: typing.Optional[builtins.int]
    seconds: typing.Optional[builtins.int]
    ticks: typing.Optional[builtins.int]
    ranges: typing.Optional[builtins.int]
    unknown: builtins.bool
    duration: datetime.timedelta
    def __str__(self) -> builtins.str:
        ...

    @staticmethod
    def from_str(timeframe:builtins.str) -> Timeframe:
        ...

    def __repr__(self) -> builtins.str:
        ...

    @staticmethod
    def Years(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Months(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Weeks(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Days(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Hours(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Minutes(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Seconds(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Ticks(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Ranges(value:builtins.int) -> Timeframe:
        ...

    @staticmethod
    def Unknown() -> Timeframe:
        ...

    @staticmethod
    def from_duration(duration:datetime.timedelta) -> Timeframe:
        ...


class Trade:
    size: builtins.float
    entry: typing.Optional[TradeEvent]
    exit: typing.Optional[TradeEvent]
    pnl: builtins.float
    direction: TradeDirection
    is_active: builtins.bool
    is_closed: builtins.bool
    def to_dict(self) -> typing.Any:
        ...


class TradeEvent:
    id: typing.Optional[builtins.str]
    order_bar_index: builtins.int
    fill_bar_index: builtins.int
    price: builtins.float
    comment: typing.Optional[builtins.str]
    def to_dict(self) -> typing.Any:
        ...


class TradeDirection(Enum):
    Long = auto()
    Short = auto()

def accuracy(tp_count:builtins.float, fp_count:builtins.float, fn_count:builtins.float, tn_count:builtins.float) -> builtins.float:
    ...

def avg_losing_trade(gross_loss:builtins.float, losing_trades:builtins.int) -> builtins.float:
    ...

def avg_trade(net_profit:builtins.float, closed_trades:builtins.int) -> builtins.float:
    ...

def avg_win_loss_ratio(avg_winning_trade:builtins.float, avg_losing_trade:builtins.float) -> builtins.float:
    ...

def avg_winning_trade(gross_profit:builtins.float, winning_trades:builtins.int) -> builtins.float:
    ...

def expectancy(pnl:typing.Sequence[builtins.float]) -> builtins.float:
    ...

def expectancy_score(expectancy:builtins.float, opportunity_bars:builtins.float) -> builtins.float:
    ...

def f1(precision:builtins.float, recall:builtins.float) -> builtins.float:
    ...

def gross_loss_pct(gross_loss:builtins.float, initial_capital:builtins.float) -> builtins.float:
    ...

def gross_profit_pct(gross_profit:builtins.float, initial_capital:builtins.float) -> builtins.float:
    ...

def long_net_profit_pct(long_net_profit:builtins.float, initial_capital:builtins.float) -> builtins.float:
    ...

def long_net_profit_ratio(long_net_profit:builtins.float, short_net_profit:builtins.float) -> builtins.float:
    ...

def net_profit_pct(net_profit:builtins.float, initial_capital:builtins.float) -> builtins.float:
    ...

def omega_ratio(positive_returns_sum:builtins.float, negative_returns_sum:builtins.float, risk_free_rate:builtins.float) -> builtins.float:
    ...

def omega_ratio_from_returns(returns:typing.Sequence[builtins.float], risk_free_rate:builtins.float) -> builtins.float:
    ...

def order_size(equity_pct:builtins.float, equity:builtins.float, exchange_rate:builtins.float, instrument_price:builtins.float, point_value:builtins.float) -> builtins.float:
    ...

def order_size_for_equity_pct(equity_pct:builtins.float, equity:builtins.float, current_position:builtins.float, instrument_price:builtins.float, point_value:builtins.float, exchange_rate:builtins.float) -> builtins.float:
    ...

def pnl(qty:builtins.float, entry_price:builtins.float, current_price:builtins.float) -> builtins.float:
    ...

def precision(tp_count:builtins.float, fp_count:builtins.float) -> builtins.float:
    ...

def profit_factor(gross_profit:builtins.float, gross_loss:builtins.float) -> builtins.float:
    ...

def py_zip_ohlcv_bars(open_time:typing.Optional[typing.Sequence[typing.Optional[datetime.datetime]]]=None, close_time:typing.Optional[typing.Sequence[typing.Optional[datetime.datetime]]]=None, open:typing.Optional[typing.Sequence[builtins.float]]=None, high:typing.Optional[typing.Sequence[builtins.float]]=None, low:typing.Optional[typing.Sequence[builtins.float]]=None, close:typing.Optional[typing.Sequence[builtins.float]]=None, volume:typing.Optional[typing.Sequence[builtins.float]]=None) -> builtins.list[OhlcvBar]:
    ...

def recall(tp_count:builtins.float, fn_count:builtins.float) -> builtins.float:
    ...

def round_contracts(size:builtins.float, min_qty:builtins.float, price_scale:builtins.float) -> builtins.float:
    ...

def round_to_min_tick(value:builtins.float, min_tick:builtins.float) -> builtins.float:
    ...

def sharpe_ratio(mean_returns:builtins.float, std_returns:builtins.float, risk_free_rate:builtins.float) -> builtins.float:
    ...

def sharpe_ratio_from_returns(returns:typing.Sequence[builtins.float], risk_free_rate:builtins.float) -> builtins.float:
    ...

def short_net_profit_pct(short_net_profit:builtins.float, initial_capital:builtins.float) -> builtins.float:
    ...

def sortino_ratio(mean_returns:builtins.float, negative_returns_stdev:builtins.float, risk_free_rate:builtins.float) -> builtins.float:
    ...

def sortino_ratio_from_returns(returns:typing.Sequence[builtins.float], risk_free_rate:builtins.float) -> builtins.float:
    ...

def validate_contracts(size:builtins.float, min_qty:builtins.float) -> builtins.bool:
    ...

def win_rate(profitable_trades:builtins.int, total_trades:builtins.int) -> builtins.float:
    ...

